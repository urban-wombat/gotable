package gotables

import (
	"bytes"
	"fmt"
	"unicode"
)

// The word size on the machine we're now running on.
func WordSize() int {
	return 32 << (^uint(0) >> 32 & 1)
}

// The word size on the machine the TypeStruct was generated on?
// This may not be right.
func GenerateWordSize() string {
//	var buf bytes.Buffer

	var s string = ""
	return s
}

func (table *Table) GenerateTypeStruct() (string, error) {
	if table == nil {
		return "", fmt.Errorf("table.%s() table is <nil>", funcName())
	}

	var buf bytes.Buffer

	buf.WriteString("type ")
	buf.WriteString(table.Name())
	buf.WriteString(" struct {\n")
	for colIndex := 0; colIndex < table.ColCount(); colIndex++ {
		colName, err := table.ColName(colIndex)
		if err != nil {
			return "", err
		}
		colType, err := table.ColTypeByColIndex(colIndex)
		if err != nil {
			return "", err
		}
		buf.WriteString("\t")
		buf.WriteString(colName)
		buf.WriteString(" ")
		buf.WriteString(colType)
		buf.WriteString("\n")
	}

	buf.WriteString("}\n")

	var typeStruct string = buf.String()
	return typeStruct, nil
}

func (tableSet *TableSet) GenerateTypeStructSet() (string, error) {
	if tableSet == nil {
		return "", fmt.Errorf("tableSet.%s() tableSet is <nil>", funcName())
	}
	
	var buf bytes.Buffer
	var delim string = ""

	for tableIndex := 0; tableIndex < tableSet.TableCount(); tableIndex++ {
		table, err := tableSet.TableByTableIndex(tableIndex)
		if err != nil {
			return "", err
		}
		typeStruct, err := table.GenerateTypeStruct()
		buf.WriteString(delim)
		buf.WriteString(typeStruct)
		delim = "\n"
	}

	var typeStruct string = buf.String()
	return typeStruct, nil
}

// Function to populate a slice of struct generated by this TypeStruct function.
// Generate ascii func definition that takes a table pointer as argument.
func (table *Table) GenerateTypeStructSliceFromTable() (string, error) {
	if table == nil {
		return "", fmt.Errorf("table.%s() table is <nil>", funcName())
	}

	var buf bytes.Buffer

	tableName := table.Name()
	buf.WriteString(fmt.Sprintf("func TypeStructSlice_%s_FromTable(table *gotables.Table) ([]%s, error) {\n", tableName, tableName))
		buf.WriteString("\tif table == nil {\n")
			buf.WriteString("\t\treturn \"\", fmt.Errorf(\"table.%s() table is <nil>\", funcName())\n")
		buf.WriteString("\t}\n\n")

		buf.WriteString(fmt.Sprintf("\tvar %s []%s = make([]%s, table.RowCount())\n\n", tableName, tableName, tableName))

		buf.WriteString("\tfor rowIndex := 0; rowIndex < table.ColCount(); rowIndex++ {\n")
			for colIndex := 0; colIndex < table.ColCount(); colIndex++ {
				colName, err := table.ColName(colIndex)
				if err != nil {
					return "", err
				}
				colType, err := table.ColTypeByColIndex(colIndex)
				if err != nil {
					return "", err
				}
				buf.WriteString(fmt.Sprintf("\t%s, err := table.Get%s(%s, rowIndex)\n", tableName, typeProper(colType)))
				buf.WriteString(fmt.Sprintf("\t\t%s[rowIndex].%s = %s\n", tableName, colName, colName))
			}
		
		buf.WriteString("\t}\n\n")
/*
	for colIndex := 0; colIndex < table.ColCount(); colIndex++ {
		colName, err := table.ColName(colIndex)
		if err != nil {
			return "", err
		}
		colType, err := table.ColTypeByColIndex(colIndex)
		if err != nil {
			return "", err
		}
		buf.WriteString("\t")
		buf.WriteString(colName)
		buf.WriteString(" ")
		buf.WriteString(colType)
		buf.WriteString("\n")
	}

*/

	buf.WriteString("}\n")

	var typeStruct string = buf.String()
	return typeStruct, nil
}

func typeProper(typeName string) string {
	var buf bytes.Buffer
	var upshifted bool = false
	for i := 0; i < len(typeName); i++ {
		if !upshifted && unicode.IsLetter(typeName[i]) {
			var upper byte = bytes.ToUpper(typeName[i])
			_ := buf.WriteByte(upper)
		} else {
			_ := buf.WriteByte(typeName[i])
		}
	}

	return buf.String()
}
